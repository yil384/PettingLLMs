import copy
import logging
from typing import Any

from pettingllms.multi_agent_env.base.agent import Agent, AgentData
from pettingllms.multi_agent_env.base.env import Env
from typing import List
logger = logging.getLogger(__name__)

def truncatefn(s, length=300):
    if isinstance(s, str):
        pass
    else:
        s = str(s)
    if len(s) <= length:
        return s

    return s[: length // 2] + "...(truncated) ..." + s[-length // 2 :]


class SystemCGenerationAgent(Agent):
    """
    Agent specialized for generating SystemC code to solve hardware design problems.
    """

    def __init__(self, rollout_idx: int | None = None, **kwargs):
        """
        Initialize the SystemC Code Generation Agent.
        """
        super().__init__()
        self.rollout_idx = rollout_idx
        # Accept other unrelated keyword arguments for compatibility
        for key, value in (kwargs or {}).items():
            setattr(self, key, value)

    def reset(self):
        super().reset()

    def update_from_env(self, turn_idx: int, env_data: Env):
        """
        Update the agent's internal prompt after an environment step.
        """
        # Save environment data
        self.env_data = env_data

        state = getattr(env_data, "state", None)
        agent_obs = getattr(env_data, "agent_observations", None)

        def as_text(value: Any) -> str:
            if value is None:
                return ""
            if isinstance(value, list):
                return "\n".join([str(v) for v in value])
            return str(value)

        question = getattr(state, "problem", None)
        current_verilog_code = getattr(state, "generated_verilog_code", None)
        current_systemc_code_history = getattr(state, "generated_systemc_code_history", [])
        
        formatted_prompt_for_feedback = ""
        if current_verilog_code and turn_idx > 0:
            formatted_prompt_for_feedback = (
                f"The Verilog code generated by another agent:\n```verilog\n{current_verilog_code}\n```\n\n"
                f"Please review the Verilog implementation and ensure your SystemC code is functionally equivalent or complementary.\n\n"
            )
        
        if turn_idx == 0:
            # SystemC code generation mode
            formatted_prompt = (
                f"You are a helpful assistant that generates SystemC code to solve hardware design problems. Please think step by step and then generate the code.\n\n"
                f"⚠️ Important: Your solution MUST be valid SystemC code that can be compiled and simulated.\n\n"
                f"Now solve the following problem:\n\n"
                f"Problem:\n{question}\n\n"
                f"Please generate correct, efficient, and synthesizable SystemC code that solves the hardware design problem.\n\n"
                f"Respond in the format:\n\n"
                f"**Code:**\n```systemc\n// your SystemC code here\n```\n\n"
            )
        else:
            # Refinement mode
            formatted_prompt = (
                f"You are a helpful assistant that generates SystemC code to solve hardware design problems.\n\n"
                f"⚠️ Important: Your solution MUST be valid SystemC code that can be compiled and simulated.\n\n"
                f"Now solve the following problem:\n\n"
                f"Problem:\n{question}\n\n"
                f"Please refine your SystemC code to ensure it is correct, efficient, and synthesizable.\n\n"
            )
            formatted_prompt += formatted_prompt_for_feedback + (
                f"Review the Verilog implementation and ensure your SystemC code is functionally equivalent.\n"
                f"Refine the code to improve correctness and quality.\n\n"
                f"Respond in the format:\n\n"
                f"**Code:**\n```systemc\n// corrected SystemC code here\n```\n\n"
            )

        self.current_prompt = {"text": formatted_prompt, "image": None}
            
    def update_from_model(self, response: str):
        # Parse the response and update agent_data
        import re
        
        # Parse SystemC code
        code = ""
        
        # Try to match the SystemC code block in our prompt format
        matches = re.findall(r"```systemc(.*?)```", response, re.DOTALL)
        if matches:
            code = matches[-1].strip()
        else:
            # Try generic code block
            matches = re.findall(r"```(.*?)```", response, re.DOTALL)
            if matches:
                code = matches[-1].strip()
            else:
                code = "We can not extract the SystemC code in the output. "
        
        # Update the agent's current action (environment expects a raw code string)
        self.current_action = code
        
        return self.current_action

    async def step(self, env_data: Env, env_worker:Any=None):
        """
        the action is the generated SystemC code, update the state
        """
        # 1) Parse and update generated SystemC code
        gen_systemc_code = self.current_action
        env_data.state.generated_systemc_code = gen_systemc_code
        env_data.state.generated_systemc_code_history.append(gen_systemc_code)
        
        # 2) Check if both Verilog and SystemC codes are generated for comparison
        if env_data.state.generated_verilog_code and env_data.state.generated_systemc_code:
            # Both codes are generated, can compare or validate
            env_data.state.both_codes_generated = True
            # Note: Actual verification would require Verilog/SystemC simulators
            # For now, we just mark that both are available
        else:
            env_data.state.both_codes_generated = False
            
        # Success is determined by having valid SystemC code
        if gen_systemc_code and not gen_systemc_code.startswith("We can not extract"):
            self.success = True
            env_data.success = True
        else:
            self.success = False
            env_data.success = False
    
    def calculate_reward(self, env_data: Env):
        # Reward based on code quality and whether both codes are generated
        systemc_code_quality = 1.0 if (env_data.state.generated_systemc_code and 
                                       not env_data.state.generated_systemc_code.startswith("We can not extract")) else 0.0
        both_codes_bonus = 0.5 if env_data.state.both_codes_generated else 0.0
        self.agent_reward = systemc_code_quality + both_codes_bonus
                

        
    def reset(self):
        """
        Reset the agent's internal state for a new episode.
        """
        self.current_action = None
        self.current_prompt = None
        self.current_response = None
        self.current_reward = None
        self.current_info = None
        self.current_action = None
        self.current_prompt = None
        self.current_response = None