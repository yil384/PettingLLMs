import copy
import logging
from typing import Any

from pettingllms.multi_agent_env.base.agent import Agent, AgentData
from pettingllms.multi_agent_env.base.env import Env
from typing import List
logger = logging.getLogger(__name__)

def truncatefn(s, length=300):
    if isinstance(s, str):
        pass
    else:
        s = str(s)
    if len(s) <= length:
        return s

    return s[: length // 2] + "...(truncated) ..." + s[-length // 2 :]


class SystemCGenerationAgent(Agent):
    """
    Agent specialized for generating SystemC code to solve hardware design problems.
    """

    def __init__(self, rollout_idx: int | None = None, **kwargs):
        """
        Initialize the SystemC Code Generation Agent.
        """
        super().__init__()
        self.rollout_idx = rollout_idx
        # Accept other unrelated keyword arguments for compatibility
        for key, value in (kwargs or {}).items():
            setattr(self, key, value)

    def reset(self):
        super().reset()

    def update_from_env(self, turn_idx: int, env_data: Env):
        """
        Update the agent's internal prompt after an environment step.
        """
        # Save environment data
        self.env_data = env_data

        state = getattr(env_data, "state", None)
        agent_obs = getattr(env_data, "agent_observations", None)

        def as_text(value: Any) -> str:
            if value is None:
                return ""
            if isinstance(value, list):
                return "\n".join([str(v) for v in value])
            return str(value)

        question = getattr(state, "problem", None)
        current_verilog_code = getattr(state, "generated_verilog_code", None)
        current_systemc_code_history = getattr(state, "generated_systemc_code_history", [])
        
        # Get verification results if available
        verification_details = getattr(state, "verification_details", "")
        match_ratio = getattr(state, "match_ratio", 0.0)
        is_equivalent = getattr(state, "is_equivalent", False)
        
        formatted_prompt_for_feedback = ""
        if current_verilog_code and turn_idx > 0:
            formatted_prompt_for_feedback = (
                f"The Verilog code generated by another agent:\n```verilog\n{current_verilog_code}\n```\n\n"
            )
            
            # Add verification feedback if available
            if verification_details:
                if is_equivalent:
                    formatted_prompt_for_feedback += (
                        f"✅ **Verification Result**: PASSED - Verilog and SystemC are functionally equivalent!\n"
                        f"Match ratio: {match_ratio*100:.1f}%\n\n"
                    )
                else:
                    formatted_prompt_for_feedback += (
                        f"⚠️ **Verification Result**: FAILED - Functional mismatch detected!\n"
                        f"Match ratio: {match_ratio*100:.1f}%\n"
                        f"Details: {verification_details}\n\n"
                        f"Please review and fix your SystemC code to match the expected behavior.\n\n"
                    )
            else:
                formatted_prompt_for_feedback += (
                    f"Please review the Verilog implementation and ensure your SystemC code is functionally equivalent.\n\n"
                )
        
        if turn_idx == 0:
            # SystemC code generation mode
            formatted_prompt = (
                f"You are a helpful assistant that generates SystemC code to solve hardware design problems. Please think step by step and then generate the code.\n\n"
                f"⚠️ Important: Your solution MUST be valid SystemC code that can be compiled and simulated.\n\n"
                f"Now solve the following problem:\n\n"
                f"Problem:\n{question}\n\n"
                f"Please generate correct, efficient, and synthesizable SystemC code that solves the hardware design problem.\n\n"
                f"Respond in the format:\n\n"
                f"**Code:**\n```systemc\n// your SystemC code here\n```\n\n"
            )
        else:
            # Refinement mode
            formatted_prompt = (
                f"You are a helpful assistant that generates SystemC code to solve hardware design problems.\n\n"
                f"⚠️ Important: Your solution MUST be valid SystemC code that can be compiled and simulated.\n\n"
                f"Now solve the following problem:\n\n"
                f"Problem:\n{question}\n\n"
                f"Please refine your SystemC code to ensure it is correct, efficient, and synthesizable.\n\n"
            )
            formatted_prompt += formatted_prompt_for_feedback + (
                f"Review the Verilog implementation and ensure your SystemC code is functionally equivalent.\n"
                f"Refine the code to improve correctness and quality.\n\n"
                f"Respond in the format:\n\n"
                f"**Code:**\n```systemc\n// corrected SystemC code here\n```\n\n"
            )

        self.current_prompt = {"text": formatted_prompt, "image": None}
            
    def update_from_model(self, response: str):
        # Parse the response and update agent_data
        import re
        
        # Parse SystemC code
        code = ""
        
        # Try to match the SystemC code block in our prompt format
        matches = re.findall(r"```systemc(.*?)```", response, re.DOTALL)
        if matches:
            code = matches[-1].strip()
        else:
            # Try generic code block
            matches = re.findall(r"```(.*?)```", response, re.DOTALL)
            if matches:
                code = matches[-1].strip()
            else:
                code = "We can not extract the SystemC code in the output. "
        
        # Update the agent's current action (environment expects a raw code string)
        self.current_action = code
        
        return self.current_action

    async def step(self, env_data: Env, env_worker:Any=None):
        """
        the action is the generated SystemC code, update the state
        """
        # 1) Parse and update generated SystemC code
        gen_systemc_code = self.current_action
        env_data.state.generated_systemc_code = gen_systemc_code
        env_data.state.generated_systemc_code_history.append(gen_systemc_code)
        
        # 2) Check if both Verilog and SystemC codes are generated for comparison
        if env_data.state.generated_verilog_code and env_data.state.generated_systemc_code:
            # Both codes are generated, can compare or validate
            env_data.state.both_codes_generated = True
            # Note: Actual verification would require Verilog/SystemC simulators
            # For now, we just mark that both are available
        else:
            env_data.state.both_codes_generated = False
            
        # Success is determined by having valid SystemC code
        if gen_systemc_code and not gen_systemc_code.startswith("We can not extract"):
            self.success = True
            env_data.success = True
        else:
            self.success = False
            env_data.success = False
    
    def calculate_reward(self, env_data: Env):
        """
        Calculate reward based on:
        1. Code generation quality
        2. Functional equivalence verification results
        """
        state = env_data.state
        
        # Base reward for generating valid code
        systemc_code_quality = 1.0 if (state.generated_systemc_code and 
                                       not state.generated_systemc_code.startswith("We can not extract")) else 0.0
        
        # Bonus for both codes being generated
        both_codes_bonus = 0.5 if state.both_codes_generated else 0.0
        
        # Verification-based reward (most important)
        verification_reward = 0.0
        if state.equivalence_verified:
            if state.is_equivalent:
                verification_reward = 3.0  # Full equivalence bonus
            else:
                verification_reward = state.match_ratio * 2.0  # Partial match reward
        
        self.agent_reward = systemc_code_quality + both_codes_bonus + verification_reward
                

        
    def reset(self):
        """
        Reset the agent's internal state for a new episode.
        """
        self.current_action = None
        self.current_prompt = None
        self.current_response = None
        self.current_reward = None
        self.current_info = None
        self.current_action = None
        self.current_prompt = None
        self.current_response = None